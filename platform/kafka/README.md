# KRaft 기반 Kafka Cluster 설정

## 프로토콜 비교

| 프로토콜       | 인증 (Who are you?)  | 암호화 (Private?) | 권장 사용 환경                           |
| -------------- | -------------------- | ----------------- | ---------------------------------------- |
| PLAINTEXT      | 없음 (보안 없음)     | 없음 (평문 전송)  | 로컬 개발, 신뢰된 내부 Docker 네트워크   |
| SSL (TLS)      | 인증서 기반 (선택적) | 있음 (TLS)        | 보안이 필요한 전송 계층 암호화           |
| SASL_PLAINTEXT | 있음 (ID/PW 등)      | 없음 (평문 전송)  | 암호화 오버헤드가 부담되는 폐쇄적 내부망 |
| SASL_SSL       | 있음 (ID/PW 등)      | 있음 (TLS)        | 운영 환경 표준 (공용망, 클라우드)        |

## TLS/SSL의 대전제: "서버는 무조건 신분증이 있어야 한다"

TLS 통신에서 접속을 받는 쪽(서버)은 자신이 누구인지 증명할 의무가 있습니다.

서버의 의무: 접속하는 클라이언트에게 "나는 진짜 카프카 브로커다"라는 것을 증명하기 위해 **인증서(Certificate)**를 제시해야 합니다. 이 인증서와 개인키가 들어있는 보관함이 바로 **keystore**
입니다.

클라이언트의 선택: 클라이언트는 서버가 준 인증서를 보고 "음, 믿을만하군" 하고 판단합니다. 이때 사용하는 것이 **truststore**입니다.

ssl.client.auth = none의 진짜 의미
이 설정은 **"서버가 클라이언트에게 신분증을 요구할 것인가?"**에 대한 설정입니다.

None: 서버가 클라이언트의 신분증(인증서)을 확인하지 않겠다. (ID/PW 방식인 SASL로 대신하겠다는 의미이기도 합니다.)

하지만: 서버 스스로가 "나는 서버다"라고 밝히기 위한 자신의 신분증(keystore)은 여전히 가지고 있어야 합니다. 신분증이 없는 서버는 SSL 포트를 열 수 없습니다.

## 브로커 간 통신에서의 역할 (Broker A ↔ Broker B)

브로커 두 개가 서로 통신할 때, 이들은 상황에 따라 서버도 되고 클라이언트도 됩니다.

상황: 브로커 A가 브로커 B에게 데이터를 복제(Replication)할 때
브로커 B (서버 역할): SSL 포트를 열고 기다립니다.

자신의 신원을 증명해야 하므로 **keystore**가 반드시 필요합니다.

client.auth = none이므로 브로커 A의 인증서는 요구하지 않습니다.

브로커 A (클라이언트 역할): 브로커 B에게 접속합니다.

브로커 B가 준 인증서가 진짜인지 확인해야 하므로 **truststore**가 필요합니다.

자신의 신분증(keystore)은 제출하지 않아도 됩니다. (None 설정 덕분)

반대로 브로커 B가 A에게 접속할 때는 역할이 정반대가 됩니다. 결국 두 브로커 모두 "서버"로서 동작해야 하는 순간이 있기 때문에, 둘 다 keystore와 truststore를 모두 가지고 있어야 합니다.
